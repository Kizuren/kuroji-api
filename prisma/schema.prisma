generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// AniZip.prisma
model AniZip {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id Int @id

  // Basic info
  episodeCount Int @map("episode_count")
  specialCount Int @map("special_count")

  // Relationships
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  titles   AniZipTitle[]
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  images   AniZipImage[]
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes AniZipEpisode[]
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  mappings AniZipMapping?

  @@map("anizip")
}

model AniZipTitle {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id   String  @id @default(cuid())
  key  String // "x-jat", "ja", "en", etc.
  name String?

  // Foreign key to AniZip
  aniZipId Int    @map("anizip_id")
  /// @DtoRelationCanConnectOnCreate
  aniZip   AniZip @relation(fields: [aniZipId], references: [id], onDelete: Cascade)

  @@unique([aniZipId, key]) // Prevent duplicate keys for same anime
  @@map("anizip_titles")
}

model AniZipImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String  @id @default(cuid())
  coverType String? @map("cover_type")
  url       String?

  // Foreign key to AniZip
  aniZipId Int    @map("anizip_id")
  /// @DtoRelationCanConnectOnCreate
  aniZip   AniZip @relation(fields: [aniZipId], references: [id], onDelete: Cascade)

  @@map("anizip_images")
}

model AniZipEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id String @id @default(cuid())

  // Episode identification
  episodeKey            String? @map("episode_key") // The JSON key like "1", "2", etc
  episodeNumber         Int?    @map("episode_number")
  seasonNumber          Int?    @map("season_number")
  absoluteEpisodeNumber Int?    @map("absolute_episode_number")

  // TVDB info
  tvdbShowId Int? @map("tvdb_show_id")
  tvdbId     Int? @map("tvdb_id")

  // Dates and times
  airDate    String? @map("air_date")
  airDateUtc String? @map("air_date_utc")

  // Media info
  runtime  Int?
  length   Int?
  overview String?
  image    String?
  rating   String?

  // IDs
  episode  String? // string representation of episode number
  anidbEid Int?    @map("anidb_eid")

  // Relationships
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  titles   AniZipEpisodeTitle[]
  aniZipId Int                  @map("anizip_id")
  /// @DtoRelationCanConnectOnCreate
  aniZip   AniZip               @relation(fields: [aniZipId], references: [id], onDelete: Cascade)

  @@unique([aniZipId, episodeKey])
  @@map("anizip_episodes")
}

model AniZipEpisodeTitle {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id   String  @id @default(cuid())
  key  String // "ja", "en", "x-jat", etc.
  name String?

  episodeId String        @map("episode_id")
  /// @DtoRelationCanConnectOnCreate
  episode   AniZipEpisode @relation(fields: [episodeId], references: [id], onDelete: Cascade)

  @@unique([episodeId, key])
  @@map("anizip_episode_titles")
}

model AniZipMapping {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id String @id @default(cuid())

  animePlanetId String? @map("animeplanet_id")
  kitsuId       String? @map("kitsu_id")
  malId         Int?    @map("mal_id")
  type          String?
  anilistId     Int?    @map("anilist_id")
  anisearchId   Int?    @map("anisearch_id")
  anidbId       Int?    @map("anidb_id")
  notifymoeId   String? @map("notifymoe_id")
  livechartId   Int?    @map("livechart_id")
  thetvdbId     Int?    @map("thetvdb_id")
  imdbId        String? @map("imdb_id")
  themoviedbId  Int?    @map("themoviedb_id")
  anilibriaId   Int?    @map("anilibria_id")
  zoroId        String? @map("zoro_id")
  animepaheId   String? @map("animepahe_id")
  animekaiId    String? @map("animekai_id")

  // One-to-one relationship
  aniZipId Int    @unique @map("anizip_id")
  /// @DtoRelationCanConnectOnCreate
  aniZip   AniZip @relation(fields: [aniZipId], references: [id], onDelete: Cascade)

  @@map("anizip_mappings")
}


// Anilibria.prisma
model Anilibria {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                            Int      @id
  anilist_id                    Int?     @unique
  year                          Int?
  alias                         String?  @unique
  fresh_at                      String?
  created_at                    String?
  updated_at                    String?
  is_ongoing                    Boolean?
  description                   String?
  notification                  String?
  episodes_total                Int?
  external_player               String?
  is_in_production              Boolean?
  is_blocked_by_copyrights      Boolean?
  added_in_users_favorites      Int?
  average_duration_of_episode   Int?
  added_in_planned_collection   Int?
  added_in_watched_collection   Int?
  added_in_watching_collection  Int?
  added_in_postponed_collection Int?
  added_in_abandoned_collection Int?

  // Normalized relations
  /// @DtoRelationCanConnectOnCreate
  type        AnilibriaType?       @relation("AnilibriaType")
  /// @DtoRelationCanConnectOnCreate
  name        AnilibriaName?       @relation("AnilibriaName")
  /// @DtoRelationCanConnectOnCreate
  season      AnilibriaSeason?     @relation("AnilibriaSeason")
  /// @DtoRelationCanConnectOnCreate
  poster      AnilibriaPoster?     @relation("AnilibriaPoster")
  /// @DtoRelationCanConnectOnCreate
  age_rating  AnilibriaAgeRating?  @relation("AnilibriaAgeRating")
  /// @DtoRelationCanConnectOnCreate
  sponsor     AnilibriaSponsor?    @relation("AnilibriaSponsor")
  /// @DtoRelationCanConnectOnCreate
  publish_day AnilibriaPublishDay? @relation("AnilibriaPublishDay")

  // Collections
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  genres   AnilibriaGenreEdge[] @relation("AnilibriaGenres")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes AnilibriaEpisode[]   @relation("AnilibriaEpisodes")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  torrents AnilibriaTorrent[]   @relation("AnilibriaTorrents")

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist? @relation(fields: [anilist_id], references: [id])
}

model AnilibriaPublishDay {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  anilibriaId Int     @unique
  value       Int?
  description String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaPublishDay", fields: [anilibriaId], references: [id])
}

model AnilibriaType {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  anilibriaId Int     @unique
  value       String?
  description String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaType", fields: [anilibriaId], references: [id])
}

model AnilibriaName {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  anilibriaId Int     @unique
  main        String?
  english     String?
  alternative String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaName", fields: [anilibriaId], references: [id])
}

model AnilibriaSeason {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  anilibriaId Int     @unique
  value       String?
  description String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaSeason", fields: [anilibriaId], references: [id])
}

model AnilibriaPoster {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                  Int     @id @default(autoincrement())
  anilibriaId         Int     @unique
  preview             String?
  thumbnail           String?
  optimized_preview   String?
  optimized_thumbnail String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaPoster", fields: [anilibriaId], references: [id])
}

model AnilibriaAgeRating {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int      @id @default(autoincrement())
  anilibriaId Int      @unique
  value       String?
  label       String?
  is_adult    Boolean?
  description String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaAgeRating", fields: [anilibriaId], references: [id])
}

model AnilibriaSponsor {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          String  @id
  anilibriaId Int     @unique
  title       String?
  description String?
  url_title   String?
  url         String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria @relation("AnilibriaSponsor", fields: [anilibriaId], references: [id])
}

model AnilibriaGenreEdge {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id             Int  @id @default(autoincrement())
  anilibriaId    Int
  genreId        Int
  total_releases Int?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria      @relation("AnilibriaGenres", fields: [anilibriaId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  genre     AnilibriaGenre @relation(fields: [genreId], references: [id])
}

model AnilibriaGenre {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                  Int     @id
  name                String?
  preview             String?
  thumbnail           String?
  optimized_preview   String?
  optimized_thumbnail String?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  genreEdges AnilibriaGenreEdge[]
}

model AnilibriaEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id           String  @id
  anilibriaId  Int
  name         String?
  name_english String?
  ordinal      Float?
  duration     Int?
  rutube_id    String?
  youtube_id   String?
  updated_at   String?
  sort_order   Int?
  release_id   Int?
  hls_480      String?
  hls_720      String?
  hls_1080     String?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria                @relation("AnilibriaEpisodes", fields: [anilibriaId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  ending    AnilibriaEpisodeEnding?  @relation("AnilibriaEpisodeEnding")
  /// @DtoRelationCanConnectOnCreate
  opening   AnilibriaEpisodeOpening? @relation("AnilibriaEpisodeOpening")
  /// @DtoRelationCanConnectOnCreate
  preview   AnilibriaEpisodePreview? @relation("AnilibriaEpisodePreview")
}

model AnilibriaEpisodeEnding {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int    @id @default(autoincrement())
  episodeId String @unique
  start     Int?
  stop      Int?

  /// @DtoRelationCanConnectOnCreate
  episode AnilibriaEpisode @relation("AnilibriaEpisodeEnding", fields: [episodeId], references: [id])
}

model AnilibriaEpisodeOpening {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int    @id @default(autoincrement())
  episodeId String @unique
  start     Int?
  stop      Int?

  /// @DtoRelationCanConnectOnCreate
  episode AnilibriaEpisode @relation("AnilibriaEpisodeOpening", fields: [episodeId], references: [id])
}

model AnilibriaEpisodePreview {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                  Int     @id @default(autoincrement())
  episodeId           String  @unique
  preview             String?
  thumbnail           String?
  optimized_preview   String?
  optimized_thumbnail String?

  /// @DtoRelationCanConnectOnCreate
  episode AnilibriaEpisode @relation("AnilibriaEpisodePreview", fields: [episodeId], references: [id])
}

model AnilibriaTorrent {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id              Int      @id
  anilibriaId     Int
  hash            String?
  size            BigInt?
  label           String?
  magnet          String?
  filename        String?
  seeders         Int?
  bitrate         Int?
  leechers        Int?
  sort_order      Int?
  updated_at      String?
  is_hardsub      Boolean?
  description     String?
  created_at      String?
  completed_times Int?

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria                @relation("AnilibriaTorrents", fields: [anilibriaId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  type      AnilibriaTorrentType?    @relation("AnilibriaTorrentType")
  /// @DtoRelationCanConnectOnCreate
  color     AnilibriaTorrentColor?   @relation("AnilibriaTorrentColor")
  /// @DtoRelationCanConnectOnCreate
  codec     AnilibriaTorrentCodec?   @relation("AnilibriaTorrentCodec")
  /// @DtoRelationCanConnectOnCreate
  quality   AnilibriaTorrentQuality? @relation("AnilibriaTorrentQuality")
}

model AnilibriaTorrentType {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  torrentId   Int     @unique
  value       String?
  description String?

  /// @DtoRelationCanConnectOnCreate
  torrent AnilibriaTorrent @relation("AnilibriaTorrentType", fields: [torrentId], references: [id])
}

model AnilibriaTorrentColor {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  torrentId   Int     @unique
  value       String?
  description String?

  /// @DtoRelationCanConnectOnCreate
  torrent AnilibriaTorrent @relation("AnilibriaTorrentColor", fields: [torrentId], references: [id])
}

model AnilibriaTorrentCodec {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id               Int      @id @default(autoincrement())
  torrentId        Int      @unique
  value            String?
  label            String?
  description      String?
  label_color      String?
  label_is_visible Boolean?

  /// @DtoRelationCanConnectOnCreate
  torrent AnilibriaTorrent @relation("AnilibriaTorrentCodec", fields: [torrentId], references: [id])
}

model AnilibriaTorrentQuality {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id @default(autoincrement())
  torrentId   Int     @unique
  value       String?
  description String?

  /// @DtoRelationCanConnectOnCreate
  torrent AnilibriaTorrent @relation("AnilibriaTorrentQuality", fields: [torrentId], references: [id])
}


// Anilist.prisma
model Anilist {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id              Int           @id
  idMal           Int?          @unique
  /// @DtoRelationCanConnectOnCreate
  title           AnilistTitle? @relation("AnilistTitle")
  bannerImage     String?
  status          String?
  type            String?
  format          String?
  /// @DtoRelationCanConnectOnCreate
  coverImage      AnilistCover? @relation("AnilistCover")
  updatedAt       Int?
  description     String?
  /// @DtoRelationCanConnectOnCreate
  startDate       StartDate?    @relation("AnilistStartDate")
  /// @DtoRelationCanConnectOnCreate
  endDate         EndDate?      @relation("AnilistEndDate")
  season          String?
  seasonYear      Int?
  episodes        Int?
  duration        Int?
  countryOfOrigin String?
  isLicensed      Boolean?
  source          String?
  hashtag         String?
  isLocked        Boolean?
  isAdult         Boolean?
  averageScore    Int?
  meanScore       Int?
  score           Int?
  popularity      Int?
  trending        Int?
  favourites      Int?
  genres          String[]
  synonyms        String[]

  /// @DtoRelationCanConnectOnCreate
  trailer             AnilistTrailer?       @relation("AnilistTrailer")
  /// @DtoRelationCanConnectOnCreate
  latestAiringEpisode AnilistLatestEpisode? @relation("AnilistLatestEpisode")
  /// @DtoRelationCanConnectOnCreate
  nextAiringEpisode   AnilistNextEpisode?   @relation("AnilistNextEpisode")
  /// @DtoRelationCanConnectOnCreate
  lastAiringEpisode   AnilistLastEpisode?   @relation("AnilistLastEpisode")

  // Normalized collections
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  characters         AnilistCharacterEdge[]      @relation("AnilistCharacters")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  studios            AnilistStudioEdge[]         @relation("AnilistStudios")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  airingSchedule     AnilistAiringSchedule[]     @relation("AnilistAiringSchedules")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  tags               AnilistTagEdge[]            @relation("AnilistTags")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  rankings           AnilistRanking[]            @relation("AnilistRanking")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  externalLinks      AnilistExternalLink[]       @relation("AnilistExternalLinks")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  streamingEpisodes  AnilistStreamingEpisode[]   @relation("AnilistStreamingEpisodes")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  scoreDistribution  AnilistScoreDistribution[]  @relation("AnilistScoreDistribution")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  statusDistribution AnilistStatusDistribution[] @relation("AnilistStatusDistribution")

  /// @DtoRelationCanConnectOnCreate
  anilibria Anilibria?
  /// @DtoRelationCanConnectOnCreate
  animepahe Animepahe?
  /// @DtoRelationCanConnectOnCreate
  animekai  AnimeKai?
  /// @DtoRelationCanConnectOnCreate
  zoro      Zoro?
  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori?
  /// @DtoRelationCanConnectOnCreate
  kitsu     Kitsu?
  /// @DtoRelationCanConnectOnCreate
  mappings  Mappings?
}

model AnilistTitle {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  anilistId Int     @unique
  romaji    String?
  english   String?
  native    String?
  /// @DtoRelationCanConnectOnCreate
  anilist   Anilist @relation("AnilistTitle", fields: [anilistId], references: [id])
}

model StartDate {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  anilistId Int     @unique
  day       Int?
  month     Int?
  year      Int?
  /// @DtoRelationCanConnectOnCreate
  anilist   Anilist @relation("AnilistStartDate", fields: [anilistId], references: [id])
}

model EndDate {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  anilistId Int     @unique
  day       Int?
  month     Int?
  year      Int?
  /// @DtoRelationCanConnectOnCreate
  anilist   Anilist @relation("AnilistEndDate", fields: [anilistId], references: [id])
}

model AnilistCover {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         Int     @id @default(autoincrement())
  anilistId  Int     @unique
  color      String?
  large      String?
  medium     String?
  extraLarge String?
  /// @DtoRelationCanConnectOnCreate
  anilist    Anilist @relation("AnilistCover", fields: [anilistId], references: [id])
}

model AnilistIndex {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id
  updatedAt DateTime @default(now()) @updatedAt
  createdAt DateTime @default(now())
}

// model AnilistView {
//   id        Int      @id @default(autoincrement())
//   anilistId Int
//   ipAddress String?
//   userAgent String?
//   viewedAt  DateTime @default(now())

//   anilist Anilist @relation("AnilistViews", fields: [anilistId], references: [id])

//   @@index([anilistId, viewedAt])
//   @@index([viewedAt])
// }

// model AnilistEpisodeView {
//   id        Int      @id @default(autoincrement())
//   anilistId Int
//   episode   Int
//   provider  String
//   ipAddress String?
//   userAgent String?
//   viewedAt  DateTime @default(now())

//   anilist Anilist @relation("AnilistEpisodeViews", fields: [anilistId], references: [id])

//   @@index([anilistId, viewedAt])
//   @@index([viewedAt])
// }

model AnilistCharacterEdge {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int     @id
  anilistId   Int
  characterId Int
  role        String?

  /// @DtoRelationCanConnectOnCreate
  anilist     Anilist          @relation("AnilistCharacters", fields: [anilistId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  character   AnilistCharacter @relation(fields: [characterId], references: [id])
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  voiceActors VoiceActor[]     @relation("CharacterVoiceActors")
}

model AnilistCharacter {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id Int @id

  /// @DtoRelationCanConnectOnCreate
  name       AnilistCharacterName?  @relation("CharacterName")
  /// @DtoRelationCanConnectOnCreate
  image      AnilistCharacterImage? @relation("CharacterImage")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  animeLinks AnilistCharacterEdge[]
}

model VoiceActor {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       Int     @id
  language String?

  /// @DtoRelationCanConnectOnCreate
  name       AnilistVoiceName?      @relation("VoiceActorName")
  /// @DtoRelationCanConnectOnCreate
  image      AnilistVoiceImage?     @relation("VoiceActorImage")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  characters AnilistCharacterEdge[] @relation("CharacterVoiceActors")
}

model AnilistCharacterName {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int      @id @default(autoincrement())
  full        String?
  native      String?
  alternative String[]

  /// @DtoRelationCanConnectOnCreate
  character   AnilistCharacter? @relation("CharacterName", fields: [characterId], references: [id])
  characterId Int?              @unique
}

model AnilistCharacterImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id     Int     @id @default(autoincrement())
  large  String?
  medium String?

  /// @DtoRelationCanConnectOnCreate
  character   AnilistCharacter? @relation("CharacterImage", fields: [characterId], references: [id])
  characterId Int?              @unique
}

model AnilistVoiceName {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int      @id @default(autoincrement())
  full        String?
  native      String?
  alternative String[]

  /// @DtoRelationCanConnectOnCreate
  voiceActor   VoiceActor? @relation("VoiceActorName", fields: [voiceActorId], references: [id])
  voiceActorId Int?        @unique
}

model AnilistVoiceImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id     Int     @id @default(autoincrement())
  large  String?
  medium String?

  /// @DtoRelationCanConnectOnCreate
  voiceActor   VoiceActor? @relation("VoiceActorImage", fields: [voiceActorId], references: [id])
  voiceActorId Int?        @unique
}

model AnilistTagEdge {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id             Int      @id @default(autoincrement())
  anilistId      Int
  tagId          Int
  rank           Int?
  isMediaSpoiler Boolean?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist    @relation("AnilistTags", fields: [anilistId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  tag     AnilistTag @relation("AnilistTagEdges", fields: [tagId], references: [id])

  @@unique([anilistId, tagId])
}

model AnilistTag {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id               Int      @id
  name             String?  @unique
  description      String?
  category         String?
  isGeneralSpoiler Boolean?
  isAdult          Boolean?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  tagEdges AnilistTagEdge[] @relation("AnilistTagEdges")
}

model AnilistExternalLink {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         Int      @id
  anilistId  Int
  url        String?
  site       String?
  siteId     Int?
  type       String?
  language   String?
  color      String?
  icon       String?
  notes      String?
  isDisabled Boolean?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistExternalLinks", fields: [anilistId], references: [id])
}

model AnilistStreamingEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  anilistId Int
  title     String?
  thumbnail String?
  url       String?
  site      String?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistStreamingEpisodes", fields: [anilistId], references: [id])
}

model AnilistStudioEdge {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int      @id
  anilistId Int
  studioId  Int
  isMain    Boolean?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist       @relation("AnilistStudios", fields: [anilistId], references: [id])
  /// @DtoRelationCanConnectOnCreate
  studio  AnilistStudio @relation(fields: [studioId], references: [id])
}

model AnilistStudio {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id   Int     @id
  name String?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  animeLinks AnilistStudioEdge[]
}

model AnilistAiringSchedule {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int  @id
  anilistId Int
  episode   Int?
  airingAt  Int?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistAiringSchedules", fields: [anilistId], references: [id])
}

model AnilistLatestEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int  @id
  anilistId Int  @unique
  episode   Int?
  airingAt  Int?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistLatestEpisode", fields: [anilistId], references: [id])
}

model AnilistNextEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int  @id
  anilistId Int  @unique
  episode   Int?
  airingAt  Int?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistNextEpisode", fields: [anilistId], references: [id])
}

model AnilistLastEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int  @id
  anilistId Int  @unique
  episode   Int?
  airingAt  Int?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistLastEpisode", fields: [anilistId], references: [id])
}

model AnilistRanking {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int      @id
  anilistId Int
  rank      Int?
  type      String?
  format    String?
  year      Int?
  season    String?
  allTime   Boolean?
  context   String

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistRanking", fields: [anilistId], references: [id])
}

model AnilistTrailer {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String  @id @default(uuid())
  anilistId Int     @unique
  site      String?
  thumbnail String?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist @relation("AnilistTrailer", fields: [anilistId], references: [id])
}

model AnilistScoreDistribution {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  score     Int
  amount    Int
  anilistId Int
  /// @DtoRelationCanConnectOnCreate
  anilist   Anilist @relation("AnilistScoreDistribution", fields: [anilistId], references: [id])
}

model AnilistStatusDistribution {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int     @id @default(autoincrement())
  status    String
  amount    Int
  anilistId Int
  /// @DtoRelationCanConnectOnCreate
  anilist   Anilist @relation("AnilistStatusDistribution", fields: [anilistId], references: [id])
}

// model BasicIdAni {
//   /// @DtoReadOnly
//   /// @DtoCreateOptional
//   /// @DtoUpdateOptional
//   id    Int  @id
//   idMal Int?

//   /// @DtoRelationCanCreateOnCreate
//   /// @DtoRelationCanConnectOnCreate
//   Anilist Anilist[] @relation("AnilistRecs")
// }


// Animekai.prisma
model AnimeKai {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            String   @id
  anilistId     Int?     @unique
  title         String?
  japaneseTitle String?
  image         String?
  description   String?
  type          String?
  url           String?
  updatedAt     Int?
  subOrDub      String?
  hasSub        Boolean?
  hasDub        Boolean?
  status        String?
  season        String?
  totalEpisodes Int?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes AnimekaiEpisode[] @relation("AnimekaiEpisode")

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist? @relation(fields: [anilistId], references: [id])
}

model AnimekaiEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String   @id
  number   Int?
  title    String?
  isFiller Boolean?
  isSubbed Boolean?
  isDubbed Boolean?
  url      String?

  /// @DtoRelationCanConnectOnCreate
  animekai AnimeKai[] @relation("AnimekaiEpisode")
}


// Animepahe.prisma
model Animepahe {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id    String @id
  idMal Int? // Changed to match JSON
  idAl  Int?   @unique // Changed to match JSON

  // Title object fields
  titleEnglish  String? // title.english
  titleRomaji   String? // title.romaji
  titleJapanese String? // title.japanese

  synonyms      String[] // Array of synonyms
  description   String?
  image         String?
  banner        String? // New field from JSON
  airedEpisodes Int?
  totalEpisodes Int? // New field from JSON

  updatedAt Int @default(0)

  // Metadata fields (merged from metadata object)
  year         Int?
  season       String? // metadata.season
  status       String? // metadata.status
  type         String?
  startDate    String?
  endDate      String?
  duration     String?
  genres       String[]
  studios      String[]
  themes       String[] // New field from metadata.themes
  demographics String[] // New field from metadata.demographics

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes AnimepaheEpisode[] @relation("AnimepaheEpisode")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  externalLinks AnimepaheExternalLink[] @relation("AnimepaheExLink")

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist? @relation(fields: [idAl], references: [id])
}

model AnimepaheEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id     String  @id
  number Int?
  title  String?
  image  String?

  // Episode metadata (merged from metadata object)
  duration String? // metadata.duration
  url      String? // metadata.url

  /// @DtoRelationCanConnectOnCreate
  animepahe Animepahe[] @relation("AnimepaheEpisode")
}

model AnimepaheExternalLink {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         String @id
  url        String
  sourceName String

  /// @DtoRelationCanConnectOnCreate
  animepahe Animepahe[] @relation("AnimepaheExLink")
}


// Indexer.prisma
model AnilistIndexerState {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id               String   @id @default("anime")
  lastFetchedPage  Int
  updatedAt        DateTime @updatedAt
}

// Kitsu.prisma
model Kitsu {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String  @id
  idAl     Int?    @unique
  type     String?
  selfLink String? @map("self_link")

  // Attributes
  createdAt           DateTime? @map("created_at")
  updatedAt           DateTime? @map("updated_at")
  slug                String?   @map("slug")
  synopsis            String?   @map("synopsis")
  coverImageTopOffset Int?      @map("cover_image_top_offset")
  canonicalTitle      String?   @map("canonical_title")
  abbreviatedTitles   String[]  @map("abbreviated_titles")
  averageRating       String?   @map("average_rating")
  ratingFrequencies   Json?     @map("rating_frequencies")
  userCount           Int?      @map("user_count")
  favoritesCount      Int?      @map("favorites_count")
  startDate           DateTime? @map("start_date")
  endDate             DateTime? @map("end_date")
  popularityRank      Int?      @map("popularity_rank")
  ratingRank          Int?      @map("rating_rank")
  ageRating           String?   @map("age_rating")
  ageRatingGuide      String?   @map("age_rating_guide")
  subtype             String?
  status              String?
  tba                 String?
  episodeCount        Int?      @map("episode_count")
  episodeLength       Int?      @map("episode_length")
  youtubeVideoId      String?   @map("youtube_video_id")
  showType            String?   @map("show_type")
  nsfw                Boolean   @default(false)

  // One-to-One Relations
  /// @DtoRelationCanConnectOnCreate
  titles             KitsuTitle?
  /// @DtoRelationCanConnectOnCreate
  posterImage        KitsuPosterImage?        @relation("PosterImage")
  /// @DtoRelationCanConnectOnCreate
  coverImage         KitsuCoverImage?         @relation("CoverImage")
  /// @DtoRelationCanConnectOnCreate
  genres             KitsuGenres?
  /// @DtoRelationCanConnectOnCreate
  categories         KitsuCategories?
  /// @DtoRelationCanConnectOnCreate
  castings           KitsuCastings?
  /// @DtoRelationCanConnectOnCreate
  installments       KitsuInstallments?
  /// @DtoRelationCanConnectOnCreate
  mappings           KitsuMappings?
  /// @DtoRelationCanConnectOnCreate
  reviews            KitsuReviews?
  /// @DtoRelationCanConnectOnCreate
  mediaRelationships KitsuMediaRelationships?
  /// @DtoRelationCanConnectOnCreate
  episodes           KitsuEpisodes?
  /// @DtoRelationCanConnectOnCreate
  streamingLinks     KitsuStreamingLinks?
  /// @DtoRelationCanConnectOnCreate
  animeProductions   KitsuAnimeProductions?
  /// @DtoRelationCanConnectOnCreate
  animeCharacters    KitsuAnimeCharacters?
  /// @DtoRelationCanConnectOnCreate
  animeStaff         KitsuAnimeStaff?

  /// @DtoRelationCanConnectOnCreate
  anilist Anilist? @relation(fields: [idAl], references: [id])
}

model KitsuTitle {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id    String  @id @default(cuid())
  en    String?
  en_jp String?
  ja_jp String?

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuPosterImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String  @id @default(cuid())
  tiny     String?
  small    String?
  medium   String?
  large    String?
  original String?

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation("PosterImage", fields: [kitsuId], references: [id])
}

model KitsuCoverImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String  @id @default(cuid())
  tiny     String?
  small    String?
  large    String?
  original String?

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation("CoverImage", fields: [kitsuId], references: [id])
}

model KitsuGenres {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuCategories {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuCastings {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuInstallments {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuMappings {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuReviews {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuMediaRelationships {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuEpisodes {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuStreamingLinks {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuAnimeProductions {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuAnimeCharacters {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}

model KitsuAnimeStaff {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       String @id @default(cuid())
  selfLink String
  related  String

  kitsuId String @unique
  /// @DtoRelationCanConnectOnCreate
  kitsu   Kitsu  @relation(fields: [kitsuId], references: [id])
}


// Shikimori.prisma
model Shikimori {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                String                @id
  malId             Int?                  @unique
  name              String?
  russian           String?
  licenseNameRu     String?
  english           String?
  japanese          String?
  /// @DtoRelationCanConnectOnCreate
  poster            ShikimoriPoster?      @relation("ShikimoriPoster")
  synonyms          String[]
  kind              String?
  rating            String?
  score             Float?
  status            String?
  episodes          Int?
  episodesAired     Int?
  duration          Int?
  /// @DtoRelationCanConnectOnCreate
  airedOn           AiredOn?              @relation("ShikimoriAiredOn")
  /// @DtoRelationCanConnectOnCreate
  releasedOn        ReleasedOn?           @relation("ShikimoriReleasedOn")
  franchise         String?
  url               String?
  season            String?
  description       String?
  descriptionHtml   String?
  descriptionSource String?
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  videos            ShikimoriVideo[]      @relation("ShikimoriVideo")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  screenshots       ShikimoriScreenshot[] @relation("ShikimoriScreenshot")
  /// @DtoRelationCanConnectOnCreate
  anilist           Anilist?              @relation(fields: [malId], references: [idMal])
}

model AiredOn {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int    @id @default(autoincrement())
  shikimoriId String @unique

  year  Int?
  month Int?
  day   Int?
  date  String?

  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori @relation("ShikimoriAiredOn", fields: [shikimoriId], references: [id])
}

model ReleasedOn {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          Int    @id @default(autoincrement())
  shikimoriId String @unique

  year  Int?
  month Int?
  day   Int?
  date  String?

  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori @relation("ShikimoriReleasedOn", fields: [shikimoriId], references: [id])
}

model ShikimoriVideo {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String  @id
  url       String?
  name      String?
  kind      String?
  playerUrl String?
  imageUrl  String?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori[] @relation("ShikimoriVideo")
}

model ShikimoriScreenshot {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          String  @id
  originalUrl String?
  x166Url     String?
  x332Url     String?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori[] @relation("ShikimoriScreenshot")
}

model Title {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id      Int     @id @default(autoincrement())
  romaji  String?
  english String?
  native  String?
}

model ShikimoriPoster {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id          String @id
  shikimoriId String @unique

  originalUrl String?
  mainUrl     String?

  /// @DtoRelationCanConnectOnCreate
  shikimori Shikimori @relation("ShikimoriPoster", fields: [shikimoriId], references: [id])
}

model ReleaseIndex {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id
  addedAt   DateTime @default(now())
  updatedAt DateTime @updatedAt
}


// Tmdb.prisma
model Tmdb {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                 Int      @id
  adult              Boolean
  backdrop_path      String?
  episode_run_time   Int[]
  first_air_date     String?
  homepage           String?
  in_production      Boolean?
  last_air_date      String?
  name               String?
  number_of_episodes Int?
  number_of_seasons  Int?
  original_language  String?
  original_name      String?
  origin_country     String[]
  overview           String?
  popularity         Float?
  poster_path        String?
  tagline            String?
  status             String?
  type               String?
  vote_average       Float?
  vote_count         Int?

  /// @DtoRelationCanConnectOnCreate
  next_episode_to_air TmdbNextEpisodeToAir? @relation("NextEpisode")
  /// @DtoRelationCanConnectOnCreate
  last_episode_to_air TmdbLastEpisodeToAir? @relation("LastEpisode")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  seasons             TmdbReleaseSeason[]   @relation("TmdbReleaseSeason")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodeSeasons      TmdbSeason[]
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes            TmdbSeasonEpisode[]
}

/// Add new model for episode info
model TmdbNextEpisodeToAir {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id              Int     @id
  name            String?
  overview        String?
  vote_average    Float?
  vote_count      Int?
  air_date        String?
  episode_number  Int?
  episode_type    String?
  production_code String?
  runtime         Int?
  season_number   Int?
  show_id         Int     @unique
  still_path      String?

  /// @DtoRelationCanConnectOnCreate
  tmdb_next Tmdb? @relation("NextEpisode", fields: [show_id], references: [id])
}

model TmdbLastEpisodeToAir {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id              Int     @id
  name            String?
  overview        String?
  vote_average    Float?
  vote_count      Int?
  air_date        String?
  episode_number  Int?
  episode_type    String?
  production_code String?
  runtime         Int?
  season_number   Int?
  show_id         Int     @unique
  still_path      String?

  /// @DtoRelationCanConnectOnCreate
  tmdb_last Tmdb? @relation("LastEpisode", fields: [show_id], references: [id])
}

model TmdbReleaseSeason {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            Int     @id
  air_date      String?
  episode_count Int?
  name          String?
  overview      String? // @Lob
  poster_path   String? // handle URL concatenation in your app logic
  season_number Int
  vote_average  Float?

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  tmdb Tmdb[] @relation("TmdbReleaseSeason")
}

model TmdbSeason {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            Int     @id
  air_date      String?
  show_id       Int
  name          String?
  overview      String?
  poster_path   String?
  season_number Int
  vote_average  Float?

  /// @DtoRelationCanConnectOnCreate
  show     Tmdb                @relation(fields: [show_id], references: [id])
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes TmdbSeasonEpisode[] @relation("TmdbSeasonEpisode")
}

model TmdbSeasonEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id              Int     @id
  air_date        String?
  episode_number  Int
  episode_type    String?
  name            String?
  overview        String?
  production_code String?
  runtime         Int?
  season_number   Int
  show_id         Int
  season_id       Int?
  still_path      String?
  vote_average    Float?
  vote_count      Int?

  /// @DtoRelationCanConnectOnCreate
  show       Tmdb                     @relation(map: "TmdbSeasonEpisode_show_fkey", fields: [show_id], references: [id])
  /// @DtoRelationCanConnectOnCreate
  tmdbSeason TmdbSeason?              @relation("TmdbSeasonEpisode", fields: [season_id], references: [id])
  /// @DtoRelationCanConnectOnCreate
  images     TmdbSeasonEpisodeImages?
}

model TmdbSeasonEpisodeImages {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        Int                    @id
  episodeId Int                    @unique
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  stills    TmdbSeasonStillImage[] @relation("TmdbSeasonEpisodeStills")
  /// @DtoRelationCanConnectOnCreate
  episode   TmdbSeasonEpisode      @relation(fields: [episodeId], references: [id])
}

model TmdbSeasonStillImage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id           Int     @id @default(autoincrement())
  aspect_ratio Float?
  height       Int?
  width        Int?
  iso_639_1    String?
  file_path    String?
  vote_average Float?
  vote_count   Int?

  /// @DtoRelationCanConnectOnCreate
  tmdbEpisodeImages TmdbSeasonEpisodeImages @relation("TmdbSeasonEpisodeStills", fields: [episodeImagesId], references: [id])
  episodeImagesId   Int
}


// Tvdb.prisma
model Tvdb {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id                   Int                @id
  /// @DtoProperty
  type                 String?
  /// @DtoProperty
  name                 String?
  /// @DtoProperty
  slug                 String?
  /// @DtoProperty
  image                String?
  /// @DtoProperty
  score                Int?
  /// @DtoProperty
  runtime              Int?
  /// @DtoProperty
  lastUpdated          String?
  /// @DtoProperty
  year                 String?
  /// @DtoProperty
  nameTranslations     String[]
  /// @DtoProperty
  overviewTranslations String[]
  /// @DtoRelationCanConnectOnCreate
  status               TvdbStatus? @relation("TvdbStatus")

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  aliases              TvdbAlias[] @relation("TvdbAliases")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  artworks             TvdbArtwork[] @relation("TvdbArtworks")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  remoteIds            TvdbRemoteId[] @relation("TvdbRemote")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  trailers             TvdbTrailer[] @relation("TvdbTrailers")
}

model TvdbStatus {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id    Int @id
  /// @DtoProperty
  tvdbId Int @unique

  /// @DtoProperty
  name  String?
  /// @DtoProperty
  recordType String?
  /// @DtoProperty
  keepUpdated Boolean?

  tvdb Tvdb @relation("TvdbStatus", fields: [tvdbId], references: [id])
}

model TvdbAlias {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            Int         @id @default(autoincrement())
  /// @DtoProperty
  name          String?
  /// @DtoProperty
  language      String?
  
  tvdb Tvdb[] @relation("TvdbAliases")
  @@map("tvdb_aliases")
}

model TvdbArtwork {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            Int         @id
  /// @DtoProperty
  height        Int?
  /// @DtoProperty
  image         String?
  /// @DtoProperty
  includesText  Boolean?
  /// @DtoProperty
  language      String?
  /// @DtoProperty
  score         Int?
  /// @DtoProperty
  thumbnail     String?
  /// @DtoProperty
  type          Int?
  /// @DtoProperty
  width         Int?

  tvdb Tvdb[] @relation("TvdbArtworks")
  @@map("tvdb_artworks")
}

model TvdbRemoteId {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id            String      @id
  /// @DtoProperty
  type          Int?
  /// @DtoProperty
  sourceName    String?
 
  tvdb Tvdb[] @relation("TvdbRemote")
  @@map("tvdb_remote")
}

model TvdbTrailer {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id  Int @id
  /// @DtoProperty
  url String?
  /// @DtoProperty
  name String?
  /// @DtoProperty
  runtime Int?
  /// @DtoProperty
  language String?

  tvdb Tvdb[] @relation("TvdbTrailers")
}

model TvdbLogin {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         Int      @id @default(autoincrement())
  /// @DtoProperty
  token      String   
  /// @DtoProperty
  createDate DateTime @default(now())
  /// @DtoProperty
  expired    Boolean  @default(false)
}

model TvdbLanguageTranslation {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         Int      @id @default(autoincrement())
  /// @DtoProperty
  tvdbId     Int
  /// @DtoProperty
  name       String?
  /// @DtoProperty
  overview   String?
  /// @DtoProperty
  isAlias    Boolean?
  /// @DtoProperty
  isPrimary  Boolean?
  /// @DtoProperty
  language   String?
  /// @DtoProperty
  tagline    String?
  /// @DtoProperty
  aliases    String[]
}

model TvdbLanguage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         String      @id
  /// @DtoProperty
  name       String?
  /// @DtoProperty
  nativeName String?
  /// @DtoProperty
  shortCode  String?
}

// Update.prisma
model UpdateQueue {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id @default(uuid())
  animeId   Int      @unique // Ensures no duplicate anime in queue
  malId     Int?
  priority  String // 'high', 'medium', 'low'
  reason    String // 'today', 'week_ago', 'missed'
  addedAt   DateTime @default(now())
  retries   Int      @default(0)
  lastError String? // Store last error message for debugging
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([priority, addedAt]) // For efficient queue processing
  @@index([animeId]) // For quick lookups
}

/// @DtoReadOnly
/// @DtoCreateOptional
/// @DtoUpdateOptional
model UpdateHistory {
  id          String   @id @default(uuid())
  animeId     Int
  malId       Int?
  providers   String[] // Which providers were updated
  success     Boolean
  duration    Int? // How long it took in seconds
  errorCount  Int      @default(0)
  errors      String[] // Any errors that occurred
  triggeredBy String // 'today', 'week_ago', 'manual', etc.
  createdAt   DateTime @default(now())

  @@index([animeId, createdAt])
  @@index([success, createdAt])
}


// User.prisma
model User {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String
  role      UserRole @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  apiKeys        ApiKey[]
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  apiKeyRequests ApiKeyRequest[]
}

model ApiKey {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String     @id @default(uuid())
  userId    String
  key       String     @unique
  type      ApiKeyType @default(LIMITED)
  whatFor   String
  active    Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  usage ApiKeyUsage[]
  /// @DtoRelationCanConnectOnCreate
  user  User          @relation(fields: [userId], references: [id])
}

model ApiKeyUsage {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id @default(uuid())
  apiKeyId  String
  endpoint  String
  method    String
  origin    String?
  userAgent String?
  ip        String?
  usedAt    DateTime @default(now())

  /// @DtoRelationCanConnectOnCreate
  apiKey ApiKey @relation(fields: [apiKeyId], references: [id])
}

model ApiKeyRequest {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String              @id @default(uuid())
  userId    String
  type      ApiKeyType          @default(LIMITED)
  whatFor   String
  status    ApiKeyRequestStatus @default(PENDING)
  reason    String? // for decline or approval notes
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  /// @DtoRelationCanConnectOnCreate
  user User @relation(fields: [userId], references: [id])
}

enum UserRole {
  ADMIN
  USER
}

enum ApiKeyType {
  FULL
  LIMITED
}

enum ApiKeyRequestStatus {
  PENDING
  APPROVED
  DECLINED
}


// Zoro.prisma
model Zoro {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id    String @id
  idMal Int? // Changed to match JSON
  idAl  Int?   @unique // Changed to match JSON

  // Title object fields
  titleEnglish String? // title.english
  titleRomaji  String? // title.romaji

  synonyms      String[] // Array of synonyms
  description   String?
  image         String?
  airedEpisodes Int?

  updatedAt Int @default(0)

  // Metadata fields (merged from metadata object)
  year      Int?
  score     Float?
  season    String? // metadata.season
  rating    String?
  type      String?
  subCount  Int?
  dubCount  Int?
  adult     Boolean?
  startDate String?
  endDate   String?
  duration  String?
  genres    String[]
  studios   String[]
  producers String[]

  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  episodes ZoroEpisode[] @relation("ZoroEpisode")
  /// @DtoRelationCanCreateOnCreate
  /// @DtoRelationCanConnectOnCreate
  seasons  ZoroSeason[]  @relation("ZoroSeason")
  /// @DtoRelationCanConnectOnCreate
  anilist  Anilist?      @relation(fields: [idAl], references: [id])
}

model ZoroEpisode {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id       Int      @id
  title    String?
  number   Int?
  isFiller Boolean?

  // Episode metadata (merged from metadata object)
  titleJp String? // metadata.title_jp

  /// @DtoRelationCanConnectOnCreate
  zoro Zoro[] @relation("ZoroEpisode")
}

model ZoroSeason {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id         String  @id
  dataNumber Int? // data_number
  dataId     Int? // data_id
  season     String?
  title      String?
  image      String?

  /// @DtoRelationCanConnectOnCreate
  zoro Zoro[] @relation("ZoroSeason")
}


// Mappings.prisma
model Mappings {
  id Int @id

  mappings Mapping[] @relation("MappingsToMapping")
  episodes Episode[] @relation("MappingsToEpisode")

  anilist Anilist? @relation(fields: [id], references: [id])
}

model Mapping {
  id String @id @default(cuid())

  sourceId   String
  sourceName String

  mappingsId Int
  parent     Mappings @relation("MappingsToMapping", fields: [mappingsId], references: [id])

  @@unique([sourceId, sourceName])
}

model Episode {
  id Int @id

  number   Int
  title    String?
  overview String?
  image    String?
  runtime  Int?
  date     String?

  mappingsId Int
  parent     Mappings @relation("MappingsToEpisode", fields: [mappingsId], references: [id])
}
