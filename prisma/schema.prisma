generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Anilist.prisma
model Anilist {
  id                Int      @id
  idMal             Int?
  siteUrl           String?
  // Embedded objects stored as JSON
  title             AnilistTitle? @relation(fields: [titleId], references: [id]) // corresponds to Release.Title
  coverImage        AnilistCover? @relation(fields: [coverId], references: [id]) // corresponds to Release.CoverImage
  bannerImage       String?
  status            String?
  type              String?
  format            String?
  updatedAt         Int?
  description       String?
  startDate         StartDate? @relation(fields: [startDateId], references: [id]) // corresponds to Date (with start_year, start_month, start_day)
  endDate           EndDate? @relation(fields: [endDateId], references: [id]) // corresponds to Date (with end_year, end_month, end_day)
  season            String?
  seasonYear        Int?
  episodes          Int?
  duration          Int?
  countryOfOrigin   String?
  isLicensed        Boolean?
  source            String?
  hashtag           String?
  trailer           Json? // corresponds to Trailer
  isLocked          Boolean?
  isAdult           Boolean?
  averageScore      Int?
  meanScore         Int?
  popularity        Int?
  trending          Int?
  favourites        Int?
  genres            String[] // Element collection of strings
  synonyms          String[]
  // Complex embedded collections stored as JSON:
  recommendations   Json? // RecommendationEdgeWrapper<BasicId>
  characters        AnilistCharacter[] @relation("AnilistCharacters")
  studios           AnilistStudio[] @relation("AnilistStudios")
  airingSchedule    AnilistAiringSchedule[] @relation("AnilistAiringSchedules")
  nextAiringEpisode AnilistNextAiringEpisode? @relation("AnilistNextAiringEpisode")
  stats             Json? // Stats (including scoreDistribution and statusDistribution)

  // Normalized collections (stored in separate tables)
  tags              AnilistTag[] @relation("AnilistTags")
  externalLinks     AnilistExternalLink[] @relation("AnilistExternalLinks")
  streamingEpisodes AnilistStreamingEpisode[] @relation("AnilistStreamingEpisodes")

  titleId           Int?
  coverId           Int?
  startDateId		Int?
  endDateId			Int?
}

model AnilistTitle {
  id               Int      @id @default(autoincrement())
  romaji    String?
  english   String?
  native    String?
  anilist   Anilist[]
}

model StartDate {
  id               Int      @id @default(autoincrement())
  day       Int?
  month     Int?
  year      Int?
  anilist	Anilist[]
}

model EndDate {
  id               Int      @id @default(autoincrement())
  day       Int?
  month     Int?
  year      Int?
  anilist	Anilist[]
}

model AnilistCover {
  id               Int      @id @default(autoincrement())
  color     String?
  large     String?
  medium    String?
  extraLarge String?
  anilist	Anilist[]
}

model AnilistIndex {
  id        String   @id
  updatedAt DateTime @default(now()) @updatedAt
  createdAt DateTime @default(now())
}

model AnilistCharacter {
  id          Int      @id @default(autoincrement())
  releaseId   Int
  characterId Int?
  name        String?
  image       String?  // Store the medium image URL

  anilist     Anilist  @relation("AnilistCharacters", fields: [releaseId], references: [id])
}

model AnilistTag {
  id               Int      @id @default(autoincrement())
  releaseId        Int
  tagId            Int?
  name             String?
  description      String?
  category         String?
  rank             Int?
  isGeneralSpoiler Boolean?
  isMediaSpoiler   Boolean?
  isAdult          Boolean?
  userId           Int?

  anilist          Anilist  @relation("AnilistTags", fields: [releaseId], references: [id])
}

model AnilistExternalLink {
  id         Int      @id @default(autoincrement())
  releaseId  Int
  exLinkId   Int?
  url        String?
  site       String?
  siteId     Int?
  type       String?
  language   String?
  color      String?
  icon       String?
  notes      String?
  isDisabled Boolean?

  anilist          Anilist  @relation("AnilistExternalLinks", fields: [releaseId], references: [id])
}

model AnilistStreamingEpisode {
  id        Int     @id @default(autoincrement())
  releaseId Int
  title     String?
  thumbnail String?
  url       String?
  site      String?

  anilist          Anilist  @relation("AnilistStreamingEpisodes", fields: [releaseId], references: [id])
}

model AnilistStudio {
  id         Int      @id @default(autoincrement())
  releaseId  Int
  studioId   Int?
  name       String?
  isMain     Boolean?

  anilist    Anilist  @relation("AnilistStudios", fields: [releaseId], references: [id])
}

model AnilistAiringSchedule {
  id              Int      @id @default(autoincrement())
  releaseId       Int
  scheduleId      Int?
  episode         Int?
  airingAt        Int?

  anilist         Anilist  @relation("AnilistAiringSchedules", fields: [releaseId], references: [id])
}

model AnilistNextAiringEpisode {
  id              Int      @id @default(autoincrement())
  releaseId       Int      @unique
  episode         Int?
  airingAt        Int?
  timeUntilAiring Int?

  anilist         Anilist  @relation("AnilistNextAiringEpisode", fields: [releaseId], references: [id])
}

model BasicIdAni {
  id        Int      @id @default(autoincrement())
  idMal     Int?
}

model BasicRelease {
  id                Int      @id
  idMal             Int?
  siteUrl           String?
  title             Json?
  synonyms          String[]
  bannerImage       String?
  coverImage        Json?
  type              String?
  format            String?
  status            String?
  description       String?
  startDate         Json?
  season            String?
  seasonYear        Int?
  episodes          Int?
  episodesAired     Int?
  duration          Int?
  countryOfOrigin   String?
  popularity        Int?
  favourites        Int?
  averageScore      Int?
  meanScore         Int?
  isLocked          Boolean?
  isAdult           Boolean?
  genres            String[]
  nextAiringEpisode Json?
}

// Animekai.prisma
model AnimeKai {
  id             String        @id
  anilistId      Int?
  title          String?
  japaneseTitle  String?
  image          String?
  description    String?       // @Lob just means long text, handled by String
  type           String?
  url            String?
  subOrDub       String?
  hasSub         Boolean?
  hasDub         Boolean?
  status         String?
  season         String?
  totalEpisodes  Int?

  episodes       Json?
}

model AnimekaiEpisode {
  id         String   @id
  number     Int?
  title      String?
  isFiller   Boolean?
  isSubbed   Boolean?
  isDubbed   Boolean?
  url        String?
}

// Animepahe.prisma
model Animepahe {
  id             String              @id
  alId           Int?
  title          String?
  image          String?
  cover          String?
  hasSub         Boolean?
  status         String?
  type           String?
  releaseDate    String?
  totalEpisodes  Int?
  episodePages   Int?

  episodes       Json?
}

model AnimepaheEpisode {
  id          String   @id
  number      Int?
  title       String?
  image       String?
  duration    String?
  url         String?
}

// Shikimori.prisma
model Shikimori {
  id            String        @id
  malId         String?
  name          String?
  russian       String?
  licenseNameRu String?
  english       String?
  japanese      String?
  synonyms      String[]
  kind          String?
  rating        String?
  score         Float?
  status        String?
  episodes      Int?
  episodesAired Int?
  duration      Int?
  airedOn       Json?
  releasedOn    Json?
  url           String?
  season        String?
  poster        Json?
  posterId      Int?
  createdAt     DateTime?
  updatedAt     DateTime?
  nextEpisodeAt DateTime?
  chronology    Json?
  videos        Json?
  screenshots   Json?
}

model AiredOn {
  id        Int         @id @default(autoincrement())
  year      Int?
  month     Int?
  day       Int?
  date      String?
}

model ReleasedOn {
  id        Int         @id @default(autoincrement())
  year      Int?
  month     Int?
  day       Int?
  date      String?
}

model BasicIdShik {
  id          Int        @id @default(autoincrement())
  malId       Int?
}

model Video {
  id            Int        @id @default(autoincrement())
  videoId       String?
  videoImageUrl String?
  kind          String?
  videoName     String?
  playerUrl     String?
  videoUrl      String?
}

model Screenshot {
  id          Int        @id @default(autoincrement())
  originalUrl String?
  x166Url     String?
  x332Url     String?
}

model BasicReleaseShikimori {
  id                  Int             @id @default(autoincrement())
  idMal               Int?
  siteUrl             String?
  title               Json?
  titleId             Int?
  synonyms            String[]
  bannerImage         String?
  coverImage          Json?
  coverImageId        Int?
  type                String?
  format              String?
  status              String?
  description         String?
  startDate           Json?
  startDateId         Int?
  season              String?
  seasonYear          Int?
  episodes            Int?
  episodesAired       Int?
  duration            Int?
  countryOfOrigin     String?
  popularity          Int?
  favourites          Int?
  averageScore        Int?
  meanScore           Int?
  isLocked            Boolean?
  isAdult             Boolean?
  genres              String[]
  nextAiringEpisode   Json?
  nextAiringEpisodeId Int?
  shikimori           Json?
  shikimoriId         Int?
}

model Title {
  id           Int                     @id @default(autoincrement())
  romaji       String?
  english      String?
  native       String?
}

model CoverImage {
  id           Int                     @id @default(autoincrement())
  extraLarge   String?
  large        String?
  medium       String?
  color        String?
}

model DateDetails {
  id           Int                     @id @default(autoincrement())
  year         Int?
  month        Int?
  day          Int?
}

model AiringEpisode {
  id              Int                     @id @default(autoincrement())
  airingAt        Int?
  timeUntilAiring Int?
  episode         Int?
}

model BasicShikimori {
  id           Int                     @id @default(autoincrement())
  name         String?
  url          String?
  poster       Json? 
  posterId     Int?
}

model Poster {
  id             Int              @id @default(autoincrement())
  originalUrl    String?
  mainUrl        String?
}

model ReleaseIndex {
  id        String   @id
  addedAt   DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model LastUpdated {
  id        Int   @id @default(autoincrement())
  entityId  String
  type      String
  createdAt DateTime @default(now())
}


// Tmdb.prisma
model Tmdb {
  id                 Int      @id
  adult              Boolean
  backdrop_path      String?  // full URL constructed on getter in Java, handle that in your app logic
  episode_run_time   Int[]    // list of integers
  media_type         String?
  first_air_date     String?
  homepage           String?
  in_production      Boolean?
  last_air_date      String?
  name               String?
  number_of_episodes Int?
  number_of_seasons  Int?
  original_language  String?
  original_name      String?
  origin_country     String[] // list of countries
  overview           String?  // @Lob in Java
  popularity         Float?
  poster_path        String?  // handle URL concatenation in your app logic
  tagline            String?  // @Lob in Java
  status             String?
  type               String?
  vote_average       Float?
  vote_count         Int?

  seasons            Json?    // relation to embedded seasons
}

model TmdbReleaseSeason {
  id            Int     @id
  air_date      String?
  episode_count Int?
  name          String?
  overview      String? // @Lob
  poster_path   String? // handle URL concatenation in your app logic
  season_number Int?
  vote_average  Float?
}

model TmdbSeason {
  id            Int      @id
  air_date      String?
  show_id       Int?     // although marked with @JsonIgnore, we keep it if you need it
  name          String?
  overview      String?  // @Lob
  poster_path   String?  // handle URL concatenation in your app logic
  season_number Int?
  vote_average  Float?

  episodes      Json?    // relation to episodes
}

model TmdbSeasonEpisode {
  id             Int     @id
  air_date       String?
  episode_number Int?
  episode_type   String?
  name           String?
  overview       String? // @Lob
  production_code String?
  runtime        Int?
  season_number  Int?
  show_id        Int?
  still_path     String? // handle URL concatenation in your app logic
  vote_average   Float?
  vote_count     Int?
}

// Tvdb.prisma
model Tvdb {
  id                   Int                @id
  tmdbId               Int?
  type                 String?            // even though it's ignored in JSON, you can keep it if needed
  name                 String?
  slug                 String?
  image                String?
  score                Int?
  runtime              Int?
  lastUpdated          String?
  year                 String?
  nameTranslations     String[]           // list of translations
  overviewTranslations String[]           // list of translations

  aliases              Json?
  artworks             Json?
  remoteIds            Json?
}

model TvdbAlias {
  id            Int         @id @default(autoincrement())
  name          String?
  language      String?

  @@map("tvdb_aliases")
}

model TvdbArtwork {
  id            Int         @id
  height        Int?
  image         String?
  includesText  Boolean?
  language      String?
  score         Int?
  thumbnail     String?
  type          Int?
  width         Int?
  @@map("tvdb_artworks")
}

model TvdbRemoteId {
  id            String      @id
  type          Int?
  sourceName    String?

  @@map("tvdb_remote")
}

model TvdbLogin {
  id         Int      @id @default(autoincrement())
  token      String   
  createDate DateTime @default(now())
  expired    Boolean  @default(false)
}

// User.prisma
model User {
  id               BigInt        @id @default(autoincrement())
  username         String        @unique
  email            String        @unique
  name             String
  password         String
  status           AccountStatus @default(ACTIVE)
  reputation       Float         @default(100.0)
  isOnline         Boolean       @default(false)
  lastSeen         DateTime      @default(now())
  isEmailVerified  Boolean       @default(false)
  emailToken       String?
  emailTokenExpiry DateTime?
  favorites        String[]
  stats            UserStats     @relation(fields: [userStatsId], references: [id])
  nameHistory      NameHistory   @relation(fields: [nameHistoryId], references: [id])
  socials          Socials       @relation(fields: [socialsId], references: [id])
  roles            UserRole[]
  privacy          UserPrivacy   @relation(fields: [userPrivacyId], references: [id])
  avatar           File?         @relation(fields: [avatarId], references: [id])
  avatarId         BigInt?
  userStatsId      BigInt
  nameHistoryId    Int
  socialsId        BigInt
  userPrivacyId    BigInt
}

enum AccountStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

enum UserRole {
  ADMIN
  USER
  MODERATOR
  DEVELOPER
  TESTER
  DAYN
  GAY
  TRANSGENDER
  HELICOPTER
  FIGHTER
  ZOV
  PATRIOTIC
  BANDERA
  OTAKU
  AIM9L
  AIM9M
  AIM7F
  R60MK
  T80U
}

enum UserAccess {
  NOBODY
  FRIENDS
  EVERYONE
}

model UserPrivacy {
  id                  BigInt     @id @default(autoincrement())
  statAccess          UserAccess
  releasesAccess      UserAccess
  socialsAccess       UserAccess
  friendRequestPolicy UserAccess
  User                User[]
}

model Socials {
  id        BigInt @id @default(autoincrement())
  github    String
  telegram  String
  discord   String
  instagram String
  tiktok    String
  User      User[]
}

model NameHistory {
  id    Int      @id @default(autoincrement())
  name  String
  time  DateTime
  first Boolean
  User  User[]
}

model UserStats {
  id             BigInt      @id @default(autoincrement())
  commentsAmount Int
  collections    Int
  animes         UserAnime[]
  User           User[]
}

enum AnimeStatus {
  PLANNED
  ON_HOLD
  DROPPED
  WATCHING
  WATCHED
}

model UserAnime {
  id          BigInt      @id @default(autoincrement())
  animeId     String
  status      AnimeStatus
  addedAt     DateTime    @default(now())
  UserStats   UserStats?  @relation(fields: [userStatsId], references: [id])
  userStatsId BigInt?
}

model File {
  id           BigInt   @id @default(autoincrement())
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  uploadedAt   DateTime @default(now())
  User         User[]
}


// Zoro.prisma
model Zoro {
  id            String        @id
  title         String?
  malID         Int?
  alID          Int?
  japaneseTitle String?
  image         String?
  description   String?
  type          String?
  url           String?
  subOrDub      String?
  hasSub        Boolean?
  hasDub        Boolean?
  status        String?
  season        String?
  totalEpisodes Int?
  episodes      Json?
}

model EpisodeZoro {
  id       String  @id
  number   Int
  title    String
  isFiller Boolean
  isSubbed Boolean
  isDubbed Boolean
  url      String
}
