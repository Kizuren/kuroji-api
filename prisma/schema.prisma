generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Indexer.prisma
model IndexerState {
  id              String   @id @default("anime")
  lastFetchedPage Int
  updatedAt       DateTime @updatedAt
}


// Update.prisma
model UpdateQueue {
  /// @DtoReadOnly
  /// @DtoCreateOptional
  /// @DtoUpdateOptional
  id        String   @id @default(uuid())
  animeId   Int      @unique // Ensures no duplicate anime in queue
  malId     Int?
  priority  String // 'high', 'medium', 'low'
  reason    String // 'today', 'week_ago', 'missed'
  addedAt   DateTime @default(now())
  retries   Int      @default(0)
  lastError String? // Store last error message for debugging
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([priority, addedAt]) // For efficient queue processing
  @@index([animeId]) // For quick lookups
}

/// @DtoReadOnly
/// @DtoCreateOptional
/// @DtoUpdateOptional
model UpdateHistory {
  id          String   @id @default(uuid())
  animeId     Int
  malId       Int?
  success     Boolean
  duration    Int? // How long it took in seconds
  errorCount  Int      @default(0)
  errors      String[] // Any errors that occurred
  triggeredBy String // 'today', 'week_ago', 'manual', etc.
  createdAt   DateTime @default(now())

  @@index([animeId, createdAt])
  @@index([success, createdAt])
}


// Mappings.prisma
model Mappings {
  id Int @id

  franchise String?
  rating    String?

  titles       Title[]       @relation("MappingsToTitle")
  descriptions Description[] @relation("MappingsToDescription")
  images       Image[]       @relation("MappingsToImage")
  mappings     Mapping[]     @relation("MappingsToMapping")
  episodes     Episode[]     @relation("MappingsToEpisode")
  videos       Video[]       @relation("MappingsToVideo")
  screenshots  Screenshot[]  @relation("MappingsToScreenshot")
  artworks     Artwork[]     @relation("MappingsToArtwork")

  anime Anime @relation(fields: [id], references: [id])
}

model Mapping {
  id String @id @default(cuid())

  sourceId   String
  sourceName String

  mappingsId Int
  parent     Mappings @relation("MappingsToMapping", fields: [mappingsId], references: [id])

  @@unique([sourceId, sourceName])
}

model Episode {
  id Int @id

  number    Int
  title     String?
  overview  String?
  thumbnail EpisodeThumbnail? @relation("EpisodeToEpisodeThumbnail")
  runtime   Int?
  date      String?

  parent Mappings[] @relation("MappingsToEpisode")
}

model EpisodeThumbnail {
  id String @id @default(cuid())

  small  String?
  medium String?
  large  String?

  episodeId Int     @unique
  parent    Episode @relation("EpisodeToEpisodeThumbnail", fields: [episodeId], references: [id])
}

model Title {
  id String @id @default(cuid())

  title    String
  source   String
  language String

  parent Mappings[] @relation("MappingsToTitle")

  @@unique([title, source, language])
}

model Description {
  id String @id @default(cuid())

  description String
  source      String
  language    String

  parent Mappings[] @relation("MappingsToDescription")

  @@unique([description, source, language])
}

model Image {
  id String @id @default(cuid())

  url    String
  small  String?
  medium String?
  large  String?

  type   String
  source String

  parent Mappings[] @relation("MappingsToImage")

  @@unique([url, type, source])
}

model Video {
  url       String  @id
  title     String?
  thumbnail String?
  artist    String?
  type      String?

  parent Mappings[] @relation("MappingsToVideo")
}

model Screenshot {
  id          String  @id
  originalUrl String?
  x166Url     String?
  x332Url     String?

  parent Mappings[] @relation("MappingsToScreenshot")
}

model Artwork {
  id           Int      @id
  height       Int?
  image        String?
  includesText Boolean?
  language     String?
  score        Int?
  thumbnail    String?
  type         Int?
  width        Int?

  parent Mappings[] @relation("MappingsToArtwork")
}


// Anime.prisma
model Anime {
  id    Int  @id
  idMal Int? @unique

  title  AnimeTitle?  @relation("AnimeTitle")
  poster AnimePoster? @relation("AnimePoster")
  banner String?

  synonyms String[]

  description String?
  status      String?
  type        String?
  format      String?

  updatedAt Int

  startDate AnimeStartDate? @relation("AnimeStartDate")
  endDate   AnimeEndDate?   @relation("AnimeEndDate")

  season          String?
  seasonYear      Int?
  episodes        Int?
  duration        Int?
  countryOfOrigin String?
  isLicensed      Boolean?
  source          String?
  hashtag         String?
  isAdult         Boolean?
  score           Int?
  popularity      Int?
  trending        Int?
  favorites       Int?
  genres          AnimeGenre[] @relation("AnimeGenres")

  latestAiringEpisode AnimeLatestEpisode? @relation("AnimeLatestEpisode")
  nextAiringEpisode   AnimeNextEpisode?   @relation("AnimeNextEpisode")
  lastAiringEpisode   AnimeLastEpisode?   @relation("AnimeLastEpisode")

  airingSchedule AnimeAiringSchedule[] @relation("AnimeAiringSchedules")
  characters     AnimeCharacterEdge[]  @relation("AnimeCharacters")
  studios        AnimeStudioEdge[]     @relation("AnimeStudios")
  tags           AnimeTagEdge[]        @relation("AnimeTags")
  rankings       AnimeRanking[]        @relation("AnimeRankings")
  externalLinks  AnimeExternalLink[]   @relation("AnimeExternalLinks")

  scoreDistribution  AnimeScoreDistribution[]  @relation("AnimeScoreDistribution")
  statusDistribution AnimeStatusDistribution[] @relation("AnimeStatusDistribution")

  mappings Mappings?
}

model AnimePoster {
  id         String  @id @default(cuid())
  animeId    Int     @unique
  color      String?
  large      String?
  medium     String?
  extraLarge String?

  anime Anime @relation("AnimePoster", fields: [animeId], references: [id], map: "anime_poster_fkey")
}

model AnimeTitle {
  id      String  @id @default(cuid())
  animeId Int     @unique
  romaji  String?
  english String?
  native  String?

  anime Anime @relation("AnimeTitle", fields: [animeId], references: [id], map: "anime_title_fkey")
}

model AnimeStartDate {
  id      String @id @default(cuid())
  animeId Int    @unique
  day     Int?
  month   Int?
  year    Int?

  anime Anime @relation("AnimeStartDate", fields: [animeId], references: [id], map: "anime_start_date_fkey")
}

model AnimeEndDate {
  id      String @id @default(cuid())
  animeId Int    @unique
  day     Int?
  month   Int?
  year    Int?

  anime Anime @relation("AnimeEndDate", fields: [animeId], references: [id], map: "anime_end_date_fkey")
}

model AnimeGenre {
  id   String @id @default(cuid())
  name String @unique

  anime Anime[] @relation("AnimeGenres")
}

model AnimeAiringSchedule {
  id       Int  @id
  animeId  Int
  episode  Int?
  airingAt Int?

  anime Anime @relation("AnimeAiringSchedules", fields: [animeId], references: [id])
}

model AnimeLatestEpisode {
  id       Int  @id
  animeId  Int  @unique
  episode  Int?
  airingAt Int?

  anime Anime @relation("AnimeLatestEpisode", fields: [animeId], references: [id])
}

model AnimeNextEpisode {
  id       Int  @id
  animeId  Int  @unique
  episode  Int?
  airingAt Int?

  anime Anime @relation("AnimeNextEpisode", fields: [animeId], references: [id])
}

model AnimeLastEpisode {
  id       Int  @id
  animeId  Int  @unique
  episode  Int?
  airingAt Int?

  anime Anime @relation("AnimeLastEpisode", fields: [animeId], references: [id])
}

model AnimeCharacterEdge {
  id          Int     @id
  animeId     Int
  characterId Int
  role        String?

  anime       Anime             @relation("AnimeCharacters", fields: [animeId], references: [id])
  character   AnimeCharacter    @relation(fields: [characterId], references: [id])
  voiceActors AnimeVoiceActor[] @relation("CharacterVoiceActors")
}

model AnimeCharacter {
  id Int @id

  name       AnimeCharacterName?  @relation("CharacterName")
  image      AnimeCharacterImage? @relation("CharacterImage")
  animeLinks AnimeCharacterEdge[]
}

model AnimeVoiceActor {
  id Int @id

  language String?

  name  AnimeVoiceName?  @relation("VoiceActorName")
  image AnimeVoiceImage? @relation("VoiceActorImage")

  characters AnimeCharacterEdge[] @relation("CharacterVoiceActors")
}

model AnimeCharacterName {
  id          String   @id @default(cuid())
  full        String?
  native      String?
  alternative String[]

  character   AnimeCharacter? @relation("CharacterName", fields: [characterId], references: [id])
  characterId Int?            @unique
}

model AnimeCharacterImage {
  id     String  @id @default(cuid())
  large  String?
  medium String?

  character   AnimeCharacter? @relation("CharacterImage", fields: [characterId], references: [id])
  characterId Int?            @unique
}

model AnimeVoiceName {
  id          String   @id @default(cuid())
  full        String?
  native      String?
  alternative String[]

  voiceActor   AnimeVoiceActor? @relation("VoiceActorName", fields: [voiceActorId], references: [id])
  voiceActorId Int?             @unique
}

model AnimeVoiceImage {
  id     String  @id @default(cuid())
  large  String?
  medium String?

  voiceActor   AnimeVoiceActor? @relation("VoiceActorImage", fields: [voiceActorId], references: [id])
  voiceActorId Int?             @unique
}

model AnimeStudioEdge {
  id       Int      @id
  animeId  Int
  studioId Int
  isMain   Boolean?

  anime  Anime       @relation("AnimeStudios", fields: [animeId], references: [id])
  studio AnimeStudio @relation(fields: [studioId], references: [id])
}

model AnimeStudio {
  id   Int     @id
  name String?

  animeLinks AnimeStudioEdge[]
}

model AnimeTagEdge {
  id             String   @id @default(cuid())
  animeId        Int
  tagId          Int
  rank           Int?
  isMediaSpoiler Boolean?

  anime Anime    @relation("AnimeTags", fields: [animeId], references: [id])
  tag   AnimeTag @relation("AnimeTagEdges", fields: [tagId], references: [id])

  @@unique([animeId, tagId])
}

model AnimeTag {
  id               Int      @id
  name             String?  @unique
  description      String?
  category         String?
  isGeneralSpoiler Boolean?
  isAdult          Boolean?

  tagEdges AnimeTagEdge[] @relation("AnimeTagEdges")
}

model AnimeRanking {
  id      Int      @id
  animeId Int
  rank    Int?
  type    String?
  format  String?
  year    Int?
  season  String?
  allTime Boolean?
  context String

  anime Anime @relation("AnimeRankings", fields: [animeId], references: [id])
}

model AnimeExternalLink {
  id         Int      @id
  animeId    Int
  url        String?
  site       String?
  siteId     Int?
  type       String?
  language   String?
  color      String?
  icon       String?
  notes      String?
  isDisabled Boolean?

  anime Anime @relation("AnimeExternalLinks", fields: [animeId], references: [id])
}

model AnimeScoreDistribution {
  id      String @id @default(cuid())
  score   Int
  amount  Int
  animeId Int

  anime Anime @relation("AnimeScoreDistribution", fields: [animeId], references: [id])
}

model AnimeStatusDistribution {
  id      String @id @default(cuid())
  status  String
  amount  Int
  animeId Int

  anime Anime @relation("AnimeStatusDistribution", fields: [animeId], references: [id])
}


// Tvdb.prisma
model TvdbLogin {
  id      String @id @default(cuid())
  token      String
  createDate DateTime @default(now())
  expired    Boolean  @default(false)
}


// Api.prisma
model ApiKey {
  id        String   @id @default(cuid())
  key       String   @unique
  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  usage ApiKeyUsage[]
}

model ApiKeyUsage {
  id        String   @id @default(cuid())
  apiKeyId  String
  endpoint  String
  method    String
  origin    String?
  userAgent String?
  ip        String?
  usedAt    DateTime @default(now())

  apiKey ApiKey @relation(fields: [apiKeyId], references: [id])
}
